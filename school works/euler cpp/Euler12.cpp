/*
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

1: 1
3: 1,3
6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

Just type 500 and press enter :)
btw i often leave it as a manual enter rather then just having 500 stored so i can more easily try test cases
*/

#include <iostream>
#include <vector>

int main()
{
  // find the smallest number with at least 1000 divisors
  // (due to Hackerrank's input range)
  const int MaxDivisors = 1000;

  // store [divisors] => [smallest number]
  std::vector<int> smallest;
  smallest.push_back(0); // 0 => no divisors
  int index    = 0;
  int triangle = 0; // same as index*(index+1)/2
  while (smallest.size() < MaxDivisors)
  {
    // next triangle number
    index++;
    triangle += index;

    // performance tweak (5x faster):
    // I observed that the "best" numbers with more than 300 divisors end with a zero
    // that's something I cannot prove right now, I just "saw" that debugging my code
    if (smallest.size() > 300 && triangle % 10 != 0)
      continue;

    // find all divisors i where i*j=triangle
    // it's much faster to assume i < j, which means i*i < triangle
    // whenever we find i then there is a j, too
   int divisors = 0;
   int i        = 1;
    while (i*i < triangle)
    {
      // divisible ? yes, we found i and j, that's two divisors
      if (triangle % i == 0)
        divisors += 2;
      i++;
    }
    // if i=j then i^2=triangle and we have another divisor
    if (i*i == triangle)
      divisors++;

    // fills gaps
    while (smallest.size() <= divisors)
      smallest.push_back(triangle);
  }
 
    int minDivisors;
    std::cin >> minDivisors;

    // problem me asks for "over" x divisors => "plus one"
    std::cout << smallest[minDivisors + 1] << std::endl;
 
  system("Pause");
  return 0;
}
